# -*- coding: utf-8 -*-
"""CISTUPQ2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1p2llsHt5LVSw_I10UdNR0g1RRhSlRIPR
"""

import pandas as pd
import multiprocessing as mp
import numpy as np
import os
import seaborn as sns
import matplotlib.pyplot as plt
from math import cos, asin, sqrt, pi
df = pd.read_csv('combined_trajectories.csv')
df.dtypes

dist_user = dict()

def haversine_distance_calculator(lat1, long1, lat2, long2):
    # radius of earth in kilometres
    rad_earth = 6371 
    p = np.pi/180
  
    # Haversine formula for calculating distance between two points on a sphere given latitude, longitude coordinates
    a = 0.5 - np.cos((lat2-lat1)*p)/2 + np.cos(lat1*p) * np.cos(lat2*p) * (1-np.cos((long2-long1)*p))/2
    return 2 * rad_earth * np.arcsin(np.sqrt(a))

def calc_user_dist(df_group):
    dist = 0
    for i in range(1, len(df_group)):
        if df_group['trajectory_id'][i] == df_group['trajectory_id'][i-1]:
            # calculate distance between consecutive points in the same trajectory
            dist += haversine_distance_calculator(df_group['latitude'][i-1], df_group['longitude'][i-1], df_group['latitude'][i], df_group['longitude'][i])
        else:
            # end of trajectory, store distance for current user and reset dist
            dist_user[df_group['individual_id'][i-1]] = dist
            dist = 0

    # handle last trajectory of the last user
    dist_user[df_group['individual_id'][i]] = dist




calc_user_dist(df)
print(dist_user)

# Defining spatial ranges

Spatial_Lat_Range = [39.985,40.0]
Spatial_Long_Range = [116.4,116.65]
df_time  = df
for i in range(len(df)):
  if (df['latitude'][i]>Spatial_Lat_Range[0] and df['latitude'][i]<Spatial_Lat_Range[1] and (df['longitude'][i]>Spatial_Long_Range[0] and df['longitude'][i]<Spatial_Long_Range[1])): 
    continue
  else:
    df = df.drop(index = i)
df = df.reset_index(drop=True)

# Defining temporal ranges

Temporal_Min = 4
Temporal_Max = 6

df_orig = df_time

for i in range(len(df)):
  hour = int(df['time'][i].split(':')[0])

  if (hour>4 and hour <6):
    continue
  else:
    df_time = df_time.drop(index = i)




pivot = pd.pivot_table(df, values='latitude', index='time', columns=None, aggfunc='mean')


# plot the heatmap for latitude vs time

plt.imshow(pivot, cmap='coolwarm', aspect='auto')
plt.xlabel('Latitude')
plt.ylabel('Time')
plt.colorbar()
plt.show()

